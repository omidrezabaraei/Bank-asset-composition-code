import streamlit as st
import pandas as pd
import numpy as np
import torch
import torch.nn as nn
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error
from scipy.signal import find_peaks
from pywt import wavedec, waverec
import matplotlib.pyplot as plt
import io
from datetime import timedelta

st.set_page_config(page_title="تحلیل تکنیکال پیشرفته", layout="wide")
st.markdown("<h1 style='text-align: center; color: #1e40af;'>تحلیل تکنیکال با هوش مصنوعی (Transformer + Monte Carlo)</h1>", unsafe_allow_html=True)

# استایل RTL
st.markdown("""
<style>
    @import url('https://cdn.fontcdn.ir/Font/Persian/IRANSans/IRANSansWeb.css');
    body, .stApp {direction: rtl; font-family: 'IRANSans', Tahoma;}
    .stButton>button {background: #1d4ed8; color: white; font-size: 18px; padding: 15px;}
</style>
""", unsafe_allow_html=True)

# آپلود فایل
uploaded_file = st.file_uploader("فایل CSV داده‌های قیمتی (ستون‌های DTYYYYMMDD و CLOSE)", type=['csv'])
future_steps = st.slider("تعداد روزهای پیش‌بینی", 1, 30, 10)

if uploaded_file:
    try:
        df = pd.read_csv(uploaded_file, encoding='utf-8-sig')
        df.columns = [col.replace('<', '').replace('>', '') for col in df.columns]
        
        if 'CLOSE' not in df.columns or 'DTYYYYMMDD' not in df.columns:
            st.error("فایل باید ستون‌های CLOSE و DTYYYYMMDD داشته باشد!")
            st.stop()
            
        df = df.rename(columns={'CLOSE': 'Close', 'DTYYYYMMDD': 'Date'})
        df['Date'] = pd.to_datetime(df['Date'].astype(str).str.replace(r'\.0$', '', regex=True), format='%Y%m%d')
        df = df[['Date', 'Close']].dropna().set_index('Date').sort_index()

        # اندیکاتورها
        def add_indicators(data):
            d = data.copy()
            d['SMA_14'] = d['Close'].rolling(14).mean()
            d['EMA_14'] = d['Close'].ewm(span=14).mean()
            delta = d['Close'].diff()
            gain = delta.clip(lower=0).rolling(14).mean()
            loss = -delta.clip(upper=0).rolling(14).mean()
            rs = gain / loss
            d['RSI_14'] = 100 - (100 / (1 + rs))
            d['MACD'] = d['Close'].ewm(span=12).mean() - d['Close'].ewm(span=26).mean()
            d['BB_Mid'] = d['Close'].rolling(20).mean()
            d['BB_Std'] = d['Close'].rolling(20).std()
            d['BB_Upper'] = d['BB_Mid'] + 2 * d['BB_Std']
            d['BB_Lower'] = d['BB_Mid'] - 2 * d['BB_Std']
            coeffs = wavedec(d['Close'], 'db8', level=3)
            d['Smoothed'] = waverec(coeffs, 'db8')[:len(d)]
            d['Change%'] = d['Close'].pct_change() * 100
            return d.dropna()

        df = add_indicators(df)
        features = ['Close','SMA_14','EMA_14','RSI_14','MACD','BB_Upper','BB_Lower','Smoothed','Change%']
        X = df[features].values
        y = df['Close'].values.reshape(-1,1)

        # نرمال‌سازی
        scaler_X = MinMaxScaler()
        scaler_y = MinMaxScaler()
        X_scaled = scaler_X.fit_transform(X)
        y_scaled = scaler_y.fit_transform(y)

        # سکانس
        seq_len = 60
        X_seq, y_seq = [], []
        for i in range(len(X_scaled) - seq_len):
            X_seq.append(X_scaled[i:i+seq_len])
            y_seq.append(y_scaled[i+seq_len])
        X_seq, y_seq = np.array(X_seq), np.array(y_seq)

        split = int(0.8 * len(X_seq))
        X_train, X_test = X_seq[:split], X_seq[split:]
        y_train, y_test = y_seq[:split], y_seq[split:]

        # مدل Transformer
        class Transformer(nn.Module):
            def __init__(self):
                super().__init__()
                self.embed = nn.Linear(len(features), 128)
                encoder_layer = nn.TransformerEncoderLayer(d_model=128, nhead=8, batch_first=True, dropout=0.1)
                self.transformer = nn.TransformerEncoder(encoder_layer, num_layers=3)
                self.fc = nn.Linear(128, 1)
            def forward(self, x):
                x = self.embed(x)
                x = self.transformer(x)
                return self.fc(x[:, -1, :])

        model = Transformer()
        optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
        criterion = nn.MSELoss()

        st.write("در حال آموزش مدل...")
        for epoch in range(100):
            model.train()
            out = model(torch.FloatTensor(X_train))
            loss = criterion(out, torch.FloatTensor(y_train))
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            if (epoch+1) % 20 == 0:
                st.write(f"Epoch {epoch+1} - Loss: {loss.item():.6f}")

        # پیش‌بینی تست
        model.eval()
        with torch.no_grad():
            pred = model(torch.FloatTensor(X_test)).numpy()
            pred = scaler_y.inverse_transform(pred)
            real = scaler_y.inverse_transform(y_test)

        mae = mean_absolute_error(real, pred)
        rmse = np.sqrt(mean_squared_error(real, pred))
        mape = np.mean(np.abs((real - pred) / real)) * 100

        st.success(f"آموزش کامل شد! MAPE: {mape:.2f}% | MAE: {mae:,.0f}")

        # پیش‌بینی آینده
        last_seq = X_scaled[-seq_len:].reshape(1, seq_len, -1)
        future = []
        current = last_seq.copy()
        for _ in range(future_steps):
            with torch.no_grad():
                pred = model(torch.FloatTensor(current)).numpy()
                next_price = scaler_y.inverse_transform(pred)[0][0]
            future.append(next_price)
            # آپدیت سکانس
            new_row = current[0, -1, :].copy()
            new_row[0] = scaler_y.transform([[next_price]])[0][0]  # فقط Close
            current = np.append(current[:, 1:, :], [[[v] for v in new_row]], axis=1)

        # نمودار
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(15, 10))
        ax1.plot(real[-100:], label="واقعی", color="blue")
        ax1.plot(pred[-100:], label="پیش‌بینی تست", color="red", linestyle="--")
        ax1.set_title(f"مقایسه واقعی و پیش‌بینی (MAPE: {mape:.2f}%)")
        ax1.legend(); ax1.grid()

        future_dates = pd.date_range(df.index[-1] + timedelta(days=1), periods=future_steps)
        ax2.plot(df.index[-50:], df['Close'].iloc[-50:], label="اخیر", color="green")
        ax2.plot(future_dates, future, "ro-", label="پیش‌بینی آینده")
        ax2.set_title("پیش‌بینی آینده")
        ax2.legend(); ax2.grid()
        plt.tight_layout()
        st.pyplot(fig)

        # دانلود
        buf = io.BytesIO()
        fig.savefig(buf, format='png', dpi=300, bbox_inches='tight')
        buf.seek(0)
        st.download_button("دانلود نمودار", buf, "تحلیل_تکنیکال.png", "image/png")

        st.subheader("پیش‌بینی قیمت برای روزهای آینده:")
        for i, p in enumerate(future, 1):
            st.write(f"**روز {i}:** {p:,.0f} ریال")

    except Exception as e:
        st.error(f"خطا: {e}")

else:
    st.info("لطفاً فایل CSV را آپلود کنید (ستون‌های DTYYYYMMDD و CLOSE)")
    st.image("https://i.postimg.cc/3xY3Y3Y3X/tah.png", use_column_width=True)
